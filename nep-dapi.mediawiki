<pre>
  NEP: <to be assigned>
  Title: Unified dApp API for trusted 3rd party wallet providers (dAPI)
  Author: Nick Fujita <nickfujita@gmail.com>, Matus Zamborsky <zamborsky@gmail.com>
  Type: Standard
  Status: Draft
  Created: 2018-08-28
</pre>

==Abstract==

This NEP describes a common API interface for dApps (dAPI) to communicate with external wallet providers. The use of a trusted 3rd party wallet provider will help users feel more sure when using dApps, and the unified interface will help dApp creators to have a more synchronous developer experience when making their dApps compatible with said providers.


==Motivation==

===End Users===

As more dApps come into the ecosystem, there will be more concerns about the safety of their assets. If dApps all required users to input their private keys in order to use them, it just takes one malicious dApp to steal all their funds. By using a trusted 3rd party wallet provider which interfaces with the various dApps in the ecosystem on their behalf, users can reduce the exposure of their private keys. This will even allow users to use their hardware wallets with these wallet providers, and never reveal their private keys, even to the wallet itself.

===dApp Developers===

One of the initial hurtles for any developer when starting to develop a dApp is to create a wallet module that will allow the user and application to interface with the NEO blockchain. While there are many quality SDKs out there such as neon-js for facilitating the communication of these requests, there are often many hurtles to successfully constructing the right combination of methods, along with input and output parsing. The issue only get amplified when trying to integrate with hardware wallet providers such as a Ledger device.

While there may be several options for 3rd party wallet providers that will help them to facilitate these transactions, the is currently no common consensus on the consistency of their interfaces. With a lack of consistency in interfaces to use these wallet provider services, dApp developers will be forced to make a decision to have their platform supported by a single provider, or to double or even triple their development efforts to accommodate all the different wallet provider interfaces. This will lead to a fragmentation in the dApps ecosystem.

===Wallet providers===

Each wallet provider, when deciding on supporting dApps to utilize their services as an authentication mechanism will be faced with a decision on how to implement an API to communicate with the dApps. Provider developers can choose to create their own API from scratch, create their own version of existing projects, or aim to directly duplication an existing API. In the case that the provider decides to make their own API interface from scratch, and try to promote dApps to use it, time and effort will inevitably be wasted the provider and competing providers on getting dApp developers on board with using their custom communication interface. If we have a unified interface for such transactions, providers can spend more time on making their individual services better for their users.

Incoming request handling:
* Upon receiving a request from a dApp, get the domain of the url from which the dApp is requesting to connect.
* Prompt the user if they would like to allow a dApp connection from the requesting domain, and which account they would like to use to interact with this dApp. Up to provider to provide a account by default based on the UX of their app.
* On user approval, resolve the request and save connection status for this domain according to the user preference.
* On user denial, reject the request with the message `CONNECTION_DENIED`


==Specification==

===getProvider===
Returns information about the  dAPI provider, including who this provider is, the version of their dAPI, and the NEP that the interface is compatible with.

'''Method Interface'''

<pre>
function getProvider(): Promise<Provider>
</pre>

'''Input arguments'''

None

'''Success return value'''

object - Provider information defined by the interface below:
<pre>
interface Provider {
  name: string;
  version: string;
  compatibility: string[];
}
</pre>

The compatibility field will return a list of strings that corresponds to NEPs that the dAPI conforms to. For example:
<pre>
compatibility: [
    'NEP-14',
    'NEP-23',
    'NEP-29'
]
</pre>

'''Error return value'''

string - `NO_PROVIDER`|`CONNECTION_DENIED`

'''Example'''

<pre>
getProvider()
.then((provider: Provider) => {
  const {
    name,
    version,
    compatibility,
  } = provider;

  console.log('Provider name: ' + name);
  console.log('Provider dAPI version: ' + version);
  console.log('Provider dAPI compatibility: ' + JSON.stringify(compatibility));
})
.catch((err: string) => {
  switch(err) {
    case NO_PROVIDER:
      console.log('No provider available.');
      break;
    case CONNECTION_DENIED:
      console.log('The user rejected the request to connect with your dApp.');
      break;
  }
});
</pre>

===getAccount===
Return the Account that is currently connected to the dApp.

'''Method Interface'''

<pre>
function getAccount(): Promise<{ address: string, publicKey: string }>
</pre>

'''Input arguments'''

None

'''Success return value'''

address: string - Address of the connected account

publicKey: string - Address of the connected account

'''Error return value'''

string - `NO_PROVIDER`|`CONNECTION_DENIED`

'''Example'''

<pre>
getAccount()
.then((account: Account) => {
  const {
    address,
    publicKey,
  } = account;

  console.log('Provider address: ' + address);
  console.log('Provider public key: ' + publicKey);
})
.catch((err: string) => {
  switch(err) {
    case NO_PROVIDER:
      console.log('No provider available.');
      break;
    case CONNECTION_DENIED:
      console.log('The user rejected the request to connect with your dApp');
      break;
  }
});
</pre>



===getBalance===
Return balance of a specific asset for the connected account.

'''Method Interface'''

<pre>
function getBalance({ asset: string }): Promise<{ address: string, asset: string, amount: string }}>
</pre>

'''Input arguments'''

string - The asset symbol the check the balance for the connected account


'''Success return value'''

address: string - Address of the connected account

asset: string - Asset symbol for the requested balance

amount: string - Parsed balance of the requested asset


'''Error return value'''

string - `NO_PROVIDER`|`CONNECTION_DENIED`

'''Example'''

<pre>
getBalance()
.then((result: Result) => {
  const {
    address,
    asset,
    amount,
  } = result;

  console.log('Provider address: ' + address);
  console.log('Provider public key: ' + publicKey);
  console.log('Provider public key: ' + publicKey);
})
.catch((err: string) => {
  switch(err) {
    case NO_PROVIDER:
      console.log('No provider available.');
      break;
    case CONNECTION_DENIED:
      console.log('The user rejected the request to connect with your dApp');
      break;
  }
});
</pre>


===send===
Invoke a transfer of a specified amount of a given asset from the connected account to another account.

'''Method Interface'''

<pre>
function send({ receiver: string, asset: string, amount: string, remark?: string }): Promise<txid: string>
</pre>

'''Input arguments'''

receiver: string - Address of the receiver of the assets to be sent

asset: string - The symbol of the asset to be sent

amount: string - The parsed amount of the asset to be sent

remark?: string - (Optional) Description of the transaction to be made


'''Success return value'''

txid: string - The transaction ID of the send invocation


'''Error return value'''

string - `NO_PROVIDER`|`CONNECTION_REFUSED`|`SEND_ERROR`|`MALFORMED_ADDRESS`|`CANCELED`

'''Example'''

<pre>
send({
  receiver: 'ATaWxfUAiBcQixNPq6TvKHEHPQum9bx79d',
  asset: 'GAS',
  amount: '0.0001',
  remark: 'Hash puppy clothing purchase. Invoice#abc123',
})
.then((txid: string) => {
  console.log('Send transaction success! Transaction ID: ' + txid);
})
.catch((err: string) => {
  switch(err) {
    case NO_PROVIDER:
      console.log('No provider available.');
      break;
    case CONNECTION_REFUSED:
      console.log('Connection dApp not connected. Please call the "connect" function.');
      break;
   case SEND_ERROR:
    console.log('There was an error when broadcasting this transaction to the network.');
    break;
   case MALFORMED_ADDRESS:
      console.log('The receiver address provided is not valid.');
      break;
  case CANCELED:
    console.log('The user has canceled this transaction.');
    break;
  }
});
</pre>


===invokeRead===
Execute a contract invocation in read-only mode.

'''Method Interface'''

<pre>
type ArgumentType = `string`|`boolean`|`hash160`|`integer`|`bytearray`|`array`;

interface Argument {
  type: ArgumentType;
  value: any;
}

function invokeRead({ scriptHash: string, operation: string, args: Argument[] }): Promise<result: Object>
</pre>

'''Input arguments'''

scriptHash: string - script hash of the smart contract to invoke a read on
operation: string - operation on the smart contract to call
args: Argument[] - any input arguments for the operation


'''Success return value'''

result: Object - Response from RPC node

'''Error return value'''

string - `NO_PROVIDER`|`CONNECTION_REFUSED`|`RPC_ERROR`

'''Example'''

<pre>
invokeRead({
  scriptHash: '505663a29d83663a838eee091249abd167e928f5',
  operation: 'calculatorAdd',
  arguments: [
    {
      type: 'integer',
      value: 2
    },
    {
      type: 'integer',
      value: 10
    }
  ],
})
.then((result: Object) => {
  console.log('Read invocation result: ' + JSON.stringigy(result));
})
.catch((err: string) => {
  switch(err) {
    case NO_PROVIDER:
      console.log('No provider available.');
      break;
    case CONNECTION_REFUSED:
      console.log('Connection dApp not connected. Please call the "connect" function.');
      break;
   case RPC_ERROR:
    console.log('There was an error when broadcasting this transaction to the network.');
    break;
  }
});
</pre>


===invoke===
Execute a contract invocation.

'''Method Interface'''

<pre>
type ArgumentType = `string`|`boolean`|`hash160`|`integer`|`bytearray`|`array`;

interface Argument {
  type: ArgumentType;
  value: any;
}

function invoke({ scriptHash: string, operation: string, args: Argument[] }): Promise<txid: string>
</pre>

'''Input arguments'''

scriptHash: string - script hash of the smart contract to invoke a read on
operation: string - operation on the smart contract to call
args: Argument[] - any input arguments for the operation


'''Success return value'''

txid: string - The transaction ID of the invocation

'''Error return value'''

string - `NO_PROVIDER`|`CONNECTION_REFUSED`|`SEND_ERROR`|`MALFORMED_ADDRESS`|`CANCELED`

'''Example'''

<pre>
invoke({
  scriptHash: '505663a29d83663a838eee091249abd167e928f5',
  operation: 'storeData',
  arguments: [
    {
      type: 'string',
      value: 'hello'
    }
  ],
})
.then((txid: string) => {
  console.log('Invoke transaction success! Transaction ID: ' + txid);
})
.catch((err: string) => {
  switch(err) {
    case NO_PROVIDER:
      console.log('No provider available.');
      break;
    case CONNECTION_REFUSED:
      console.log('Connection dApp not connected. Please call the "connect" function.');
      break;
    case RPC_ERROR:
      console.log('There was an error when broadcasting this transaction to the network.');
      break;
    case CANCELED:
      console.log('The user has canceled this transaction.');
      break;
  }
});
</pre>

==Implementation==

In progress. To be finalized as consensus is reached on the specifications of this NEP.
