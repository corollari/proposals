<pre>
  NEP: <to be assigned>
  Title: Unified dApp API for wallet providers
  Author: Nick Fujita <nickfujita@gmail.com>, Matus Zamborsky <zamborsky@gmail.com>
  Type: Standard
  Status: Draft
  Created: 2018-08-28
</pre>

==Abstract==

This NEP describes a common API interface for dApps to communicate with external wallet providers. The use of a trusted 3rd party wallet providers will help users feel more secure when using dApps, and the unified interface will help dApp creators to have a more uniform developer experience when making their dApps compatible with various providers.


==Motivation==

===End Users===

As dApps come into the ecosystem, there will be more concerns about the safety of user assets. If dApps all required users to input their private keys in order to use them, it just takes one malicious dApp to steal all their funds. By using a trusted wallet provider which interfaces with the various dApps in the ecosystem on their behalf, users can reduce the exposure of their private keys. This will even allow users to transact with their hardware wallets via the wallet provider,  never having to reveal their private keys even to the wallet itself.

===dApp Developers===

One of the initial hurtles for any developer when starting to develop a dApp is to create a wallet module that will allow the user and application to interface with the NEO blockchain. While there are many quality SDKs out there such as neon-js for facilitating the communication of these requests, there are often many hurtles to successfully constructing the right combination of methods, along with input and output parsing. The issue only gets amplified when trying to integrate with hardware wallet providers such as a Ledger device.

While there may be several options for 3rd party wallet providers that will help them to facilitate these transactions, the is currently no common consensus on the consistency of their interfaces. With a lack of consistency in interfaces to use these wallet provider services, dApp developers will be forced to make a decision to have their platform supported by a single provider, or to double or even triple their development efforts to accommodate all the different wallet provider interfaces. This will lead to a fragmentation in the dApps ecosystem.

===Wallet providers===

Each wallet provider, when deciding on supporting dApps to utilize their services as an authentication mechanism will be faced with a decision on how to implement an API to communicate with the dApps. Wallet providers can choose to create their own API from scratch, create their own version of existing projects, or aim to directly duplication an existing API. In the case that the provider decides to make their own API interface from scratch, and try to promote dApps to use it, time and effort will inevitably be wasted by both the provider and competing providers on getting dApp developers on board with using their custom communication interface. If we have a unified interface for such transactions, providers can spend more time on making their individual services better for their users.

The current list of wallet providers that can benefit from the use of this protocol are currently:
* nOS dApps browser
* NeoLink Chrome extension
* NEX Chrome extension
* O3 dApps browser

Each wallet provider has their own value proposition to it's users beyond the interface from this protocol itself, so it seems that formalizing it would be a net positive for all.

Additionally, since there are a significant amount of overlap in the protocols between NEO and Ontology for sending assets, and interacting with contract on NeoVM, this proposal is a joint effort with [https://github.com/ontio/OEPs/pull/8 OEP6]. Since there are differences in the two platforms, the result of these proposals will not be identical, nor should they be, but getting as much overlap as possible will help to simplify cross-chain interactions for both platforms.


==Specification==

'''Provider Request Handling'''

Implementation details of per dApp domain handling will be left to the discretion of the wallet provider. Providers can choose to allow users to trust certain dApps to automatically execute transaction on their behalf, or a certain subset of transaction types. Below are basic guidelines for general handling of requests from dApps via the protocol interface.

===Read Methods===

====getProvider====
Returns information about the  dAPI provider, including who this provider is, the version of their dAPI, and the NEP that the interface is compatible with.


'''Method Interface'''

<pre>
function getProvider(): Promise<Provider>
</pre>


'''Input arguments'''

None


'''Success return value'''

object - Provider information defined by the interface below:
<pre>
interface Provider {
  name: string;
  website: string;
  version: string;
  compatibility: string[];
}
</pre>

The compatibility field will return a list of strings that corresponds to NEPs that the dAPI conforms to. For example:
<pre>
compatibility: [
    'NEP-14',
    'NEP-23',
    'NEP-29'
]
</pre>


'''Error return value'''

string - `NO_PROVIDER`|`CONNECTION_DENIED`


'''Example'''

<pre>
getProvider()
.then((provider: Provider) => {
  const {
    name,
    website,
    version,
    compatibility,
  } = provider;

  console.log('Provider name: ' + name);
  console.log('Provider website: ' + website);
  console.log('Provider dAPI version: ' + version);
  console.log('Provider dAPI compatibility: ' + JSON.stringify(compatibility));
})
.catch((err: string) => {
  switch(err) {
    case NO_PROVIDER:
      console.log('No provider available.');
      break;
    case CONNECTION_DENIED:
      console.log('The user rejected the request to connect with your dApp.');
      break;
  }
});
</pre>


'''Provider Request Handling'''

Upon receiving this request, return:
* The name of the provider wallet
* The provider website
* The provider specific version of the wallet
* A list of NEP for which the specific provider protocol is compatible with

Example
<pre>
{
  name: 'Awesome Wallet',
  website: 'https://www.awesome.com',
  version: 'v0.0.1',
  compatibility: [
    'NEP-14',
    'NEP-23',
    'NEP-29'
  ]
}
</pre>


====getNetworks====
Returns the networks the wallet provider has available to connect to, along with the default network the wallet is currently set to.


'''Method Interface'''

<pre>
function getNetworks(): Promise<Networks>
</pre>


'''Input arguments'''

None


'''Success return value'''

<pre>
interface Networks {
  networks: string[]; // Array of network names the wallet provider has available for the dapp developer to connect to.
  defaultNetwork: string; // Network the wallet is currently set to.
}
</pre>

'''Error return value'''

string - `NO_PROVIDER`|`CONNECTION_DENIED`


'''Example'''

<pre>
getNetworks()
.then(response => {
  const {
    networks,
    defaultNetwork,
  } = response.networks;

  console.log('Networks: ' + networks);
  // eg. ["MainNet", "TestNet", "PrivateNet"]
  
  console.log('Default network: ' + defaultNetwork);
  // eg. "MainNet"
})
.catch((err: string) => {
  switch(err) {
    case NO_PROVIDER:
      console.log('No provider available.');
      break;
    case CONNECTION_DENIED:
      console.log('The user rejected the request to connect with your dApp');
      break;
  }
});
</pre>


'''Provider Request Handling'''

Upon receiving this request, return:
- The list of NEO networks that the wallet is able to connect to. The return values will be used by the dapp developer to communicate to which network they would like their request to be directed to. The wallet provider will be responsible for the logistics of which node to submit any request to for each network alias provided.
- The wallet provider is to also return the default network that the wallet UI is currently set to by user.

Example
<pre>
{
  networks: ["MainNet", "TestNet", "PrivateNet"],
  defaultNetwork: "TestNet", 
}
</pre>


====getAccount====
Return the Account that is currently connected to the dApp.


'''Method Interface'''

<pre>
function getAccount(): Promise<{ address: string, publicKey: string }>
</pre>


'''Input arguments'''

None


'''Success return value'''

<pre>
interface Account {
  address: string; // Address of the connected account
  publicKey: string; // Public key of the connected account
}
</pre>


'''Error return value'''

string - `NO_PROVIDER`|`CONNECTION_DENIED`


'''Example'''

<pre>
getAccount()
.then((account: Account) => {
  const {
    address,
    publicKey,
  } = account;

  console.log('Provider address: ' + address);
  console.log('Provider public key: ' + publicKey);
})
.catch((err: string) => {
  switch(err) {
    case NO_PROVIDER:
      console.log('No provider available.');
      break;
    case CONNECTION_DENIED:
      console.log('The user rejected the request to connect with your dApp');
      break;
  }
});
</pre>


'''Provider Request Handling'''

Upon receiving this request, return:
- The address and public key of account currently selected by the user in the wallet interface

Example
<pre>
{
  address: 'AeysVbKWiLSuSDhg7DTzUdDyYYKfgjojru',
  publicKey: '03d43468721ef8936548878071b534d8228c313e02e6d90cef8c65fd3c2d4eaeed'
}
</pre>


====getBalance====
Return balance of a specific asset for the given account.

If the asset is omited from a request to MainNet, all asset and token balances will be returned.


'''Method Interface'''

<pre>
function getBalance(args: GetBalanceArgs): Promise<BalanceResults>}>
</pre>


'''Input arguments'''

<pre>
interface GetBalanceArgs {
  params: BalanceRequest|BalanceRequest[];
  network?: string - Network alias to submit this request to. If omitted, will default to "MainNet".
}

interface BalanceRequest {
  address: string; // Address to check balance(s)
  assets?: string|string[]; // Asset script hash to check balance.
  // Requests to "MainNet" will accept the asset symbols we well.
  // Requests to non "MainNet" will just return asset balances for NEO and GAS
  fetchUTXO?: boolean;
  // Fetches to UTXO data for NEO and/or GAS if attribute is 'true'
}
</pre>


'''Success return value'''

<pre>
interface BalanceResults {
  [address: string]: Balance[];
}

interface Balance {
  scriptHash: string;
  symbol: string;
  amount: string;
}
</pre>


'''Error return value'''

string - `NO_PROVIDER`|`CONNECTION_DENIED`


'''Example'''

<pre>
getBalance({
  params: {
    address: 'AeysVbKWiLSuSDhg7DTzUdDyYYKfgjojru',
    assets: ['NKN']
  },
  network: 'MainNet',
})
.then((results: BalanceResults) => {
  Object.keys(results).forEach(address => {
    const { balances } = results[address];
    Object.keys(balances).forEach(balance => {
      const { scriptHash, symbol, amount } = balance

      console.log('Address: ' + address);
      console.log('Asset scriptHash: ' + scriptHash);
      console.log('Asset symbol: ' + symbol);
      console.log('Amount: ' + amount);
    });
  });
})
.catch((err: string) => {
  switch(err) {
    case NO_PROVIDER:
      console.log('No provider available.');
      break;
    case CONNECTION_DENIED:
      console.log('The user rejected the request to connect with your dApp');
      break;
  }
});
</pre>

Single asset balance request sample
<pre>
// input
{
  params: {
    address: 'AeysVbKWiLSuSDhg7DTzUdDyYYKfgjojru',
    assets: ['NKN']
  },
  network: 'MainNet',
}

// output
{
  'AeysVbKWiLSuSDhg7DTzUdDyYYKfgjojru': [
    {
      'scriptHash': 'c36aee199dbba6c3f439983657558cfb67629599',
      'symbol': 'NKN',
      'amount': '0.00000233',
    }
  ],
}
</pre>

Single account balances request sample
<pre>
// input
{
  params: {
    address: 'AeysVbKWiLSuSDhg7DTzUdDyYYKfgjojru',
  },
  network: 'MainNet',
}

// output
{
  'AeysVbKWiLSuSDhg7DTzUdDyYYKfgjojru': [
    {
      'scriptHash': 'c56f33fc6ecfcd0c225c4ab356fee59390af8560be0e930faebe74a6daff7c9b',
      'symbol': 'NEO',
      'amount': '10',
    },
    {
      'scriptHash': '602c79718b16e442de58778e148d0b1084e3b2dffd5de6b7b16cee7969282de7',
      'symbol': 'GAS',
      'amount': '777.0001',
    },
    {
      'scriptHash': 'c36aee199dbba6c3f439983657558cfb67629599',
      'symbol': 'NKN',
      'amount': '0.00000233',
    },
    {
      'scriptHash': 'fc732edee1efdf968c23c20a9628eaa5a6ccb934',
      'symbol': 'NNC',
      'amount': '2000',
    }
  ]
}

Multiple account balances request sample
<pre>
// input
{
  params: [
    {
      address: 'AeysVbKWiLSuSDhg7DTzUdDyYYKfgjojru',
    },
    {
      address: 'AbKNY45nRDy6B65YPVz1B6YXiTnzRqU2uQ',
      asset: 'PHX',
    },
  ],
  network: 'MainNet',
}

// output
{
  'AeysVbKWiLSuSDhg7DTzUdDyYYKfgjojru': [
    {
      'scriptHash': 'c56f33fc6ecfcd0c225c4ab356fee59390af8560be0e930faebe74a6daff7c9b',
      'symbol': 'NEO',
      'amount': '10',
    },
    {
      'scriptHash': '602c79718b16e442de58778e148d0b1084e3b2dffd5de6b7b16cee7969282de7',
      'symbol': 'GAS',
      'amount': '777.0001',
    },
    {
      'scriptHash': 'c36aee199dbba6c3f439983657558cfb67629599',
      'symbol': 'NKN',
      'amount': '0.00000233',
    },
    {
      'scriptHash': 'fc732edee1efdf968c23c20a9628eaa5a6ccb934',
      'symbol': 'NNC',
      'amount': '2000',
    }
  ],
  'AbKNY45nRDy6B65YPVz1B6YXiTnzRqU2uQ': [
    {
      'scriptHash': '1578103c13e39df15d0d29826d957e85d770d8c9',
      'symbol': 'PHX',
      'amount': '11000',
    }
  ]
}
</pre>

'''Provider Request Handling'''

Upon receiving this request, fetch the latest balance(s) for each given account, for the specific asset if applicable.
Typechecking will be required on the input argument, as it can be eather a single BalanceRequest object, or an array of BalanceRequest objects. In the case where a specific asset is not provided to check the balance for, the wallet provider will fetch balances for all assets and tokens for that account.


====getStorage====
Reads the raw value in smart contract storage.


'''Method Interface'''

<pre>
function getStorage({ scriptHash: string, key: string, network?: string }): Promise<StorageResponse>
</pre>


'''Input arguments'''

<pre>
interface GetStorageArgs {
  scriptHash: string; // script hash of the smart contract to invoke a read on
  key: string; // key of the storage value to retrieve from the contract
  network?: string; // Network alias to submit this request to. If omitted, will default to "MainNet".
}
</pre>


'''Success return value'''

<pre>
interface StorageResponse {
  result: string; // The raw value that's stored in the contract
}
</pre>


'''Error return value'''

string - `NO_PROVIDER`|`CONNECTION_REFUSED`|`RPC_ERROR`


'''Example'''

<pre>
getStorage({
  scriptHash: '505663a29d83663a838eee091249abd167e928f5',
  key: 'game.status',
  network: 'TestNet'
})
.then(res => {
  const value = res.result;
  console.log('Storage value: ' + value);
})
.catch((err: string) => {
  switch(err) {
    case NO_PROVIDER:
      console.log('No provider available.');
      break;
    case CONNECTION_REFUSED:
      console.log('Connection dApp not connected. Please call the "connect" function.');
      break;
    case RPC_ERROR:
      console.log('There was an error when broadcasting this transaction to the network.');
      break;
  }
});
</pre>


'''Provider Request Handling'''

Upon receiving this request
* Validate and format the inputs
** Script hash is valid
* Broadcast the RPC request
* Return the RPC response results

Example
<pre>
{
  result: 'hello world'
}
</pre>


====invokeRead====
Execute a contract invocation in read-only mode.


'''Method Interface'''

<pre>
function invokeRead({
  scriptHash: string,
  operation: string,
  args: Argument[]
  network?: string,
 }): Promise<result: Object>
</pre>

'''Input arguments'''

<pre>
interface InvokeReadArgs {
  scriptHash: string; // script hash of the smart contract to invoke a read on
  operation: string; // operation on the smart contract to call
  args: Argument[]; // any input arguments for the operation
  network?: string; // Network alias to submit this request to. If omitted, will default to "MainNet".
}

interface Argument {
  type: ArgumentDataType;
  value: any;
}

type ArgumentDataType = 'String'|'Boolean'|'Hash160'|'Integer'|'ByteArray'|'Array'|'Address';
</pre>


'''Success return value'''

result: Object - Response from RPC node


'''Error return value'''

string - `NO_PROVIDER`|`CONNECTION_REFUSED`|`RPC_ERROR`


'''Example'''

<pre>
invokeRead({
  scriptHash: '505663a29d83663a838eee091249abd167e928f5',
  operation: 'calculatorAdd',
  arguments: [
    {
      type: 'integer',
      value: 2
    },
    {
      type: 'integer',
      value: 10
    }
  ],
  network: 'PrivNet'
})
.then((result: Object) => {
  console.log('Read invocation result: ' + JSON.stringigy(result));
})
.catch((err: string) => {
  switch(err) {
    case NO_PROVIDER:
      console.log('No provider available.');
      break;
    case CONNECTION_REFUSED:
      console.log('Connection dApp not connected. Please call the "connect" function.');
      break;
   case RPC_ERROR:
    console.log('There was an error when broadcasting this transaction to the network.');
    break;
  }
});
</pre>


'''Provider Request Handling'''

Upon receiving this request
* Validate and format the inputs
** Script hash is valid
** Format parameters
*** If `byteArray`, convert to appropriate hexstring based on assumed format
* Broadcast the RPC request
* Return the RPC response results

Example
<pre>
{
  script: '8h89fh398f42f.....89hf2894hf9834',
  state: 'HALT, BREAK',
  gas_consumed: '0.13',
  stack: [
    {
      type: 'Integer',
      value: '1337'
    }
  ]
}
</pre>


===Write Methods===
====send====
Invoke a transfer of a specified amount of a given asset from the connected account to another account.


'''Method Interface'''

<pre>
function send({
  fromAddress: string,
  toAddress: string,
  asset: string,
  amount: string,
  remark?: string,
  fee?: string,
  network?: string,
}): Promise<SendOutput>
</pre>


'''Input arguments'''

<pre>
interface SendArgs {
  fromAddress: string; // Address of the connected account to send the assets from
  toAddress: string; // Address of the receiver of the assets to be sent
  asset: string; // Asset script hash to be sent. Accepts asset symbol only for "MainNet"
  amount: string; // The parsed amount of the asset to be sent
  remark?: string; // (Optional) Description of the transaction to be made
  fee?: string; // (Optional) The parsed amount of network fee (in GAS) to include with transaction
  network?: string; // Network alias to submit this request to. If omitted, will default to "MainNet".
}
</pre>


'''Success return value'''

<pre>
interface SendOutput {
  txid: string; // The transaction ID of the send invocation
  nodeUrl: string; // The node which the transaction was broadcast to.
}
</pre>


'''Error return value'''

string - `NO_PROVIDER`|`CONNECTION_REFUSED`|`SEND_ERROR`|`MALFORMED_ADDRESS`|`CANCELED`|`INSUFFICIENT_FUNDS`


'''Example'''

<pre>
send({
  fromAddress: 'ATaWxfUAiBcQixNPq6TvKHEHPQum9bx79d',
  toAddress: 'ATaWxfUAiBcQixNPq6TvKHEHPQum9bx79d',
  asset: 'GAS',
  amount: '0.0001',
  remark: 'Hash puppy clothing purchase. Invoice#abc123',
  fee: '0.0001',
  network: 'MainNet'
})
.then(({txid, nodeUrl}: SendOutput) => {
  console.log('Send transaction success!');
  console.log('Transaction ID: ' + txid);
  console.log('RPC node URL: ' + nodeUrl);
})
.catch((err: string) => {
  switch(err) {
    case NO_PROVIDER:
      console.log('No provider available.');
      break;
    case CONNECTION_REFUSED:
      console.log('dApp not connected. Please call the "connect" function.');
      break;
    case SEND_ERROR:
      console.log('There was an error when broadcasting this transaction to the network.');
      break;
    case MALFORMED_ADDRESS:
      console.log('The receiver address provided is not valid.');
      break;
    case CANCELED:
      console.log('The user has canceled this transaction.');
      break;
    case INSUFFICIENT_FUNDS:
      console.log('The user has insufficient funds to execute this transaction.');
      break;
  }
});
</pre>


'''Provider Request Handling'''

Upon receiving this request
* Validate the inputs
** From address matches connected account
** To address is valid
** Map asset symbol to script hash of one is provided instead of script hash
** Amount is valid value, and account has enough balance
* Broadcast the RPC request
* Return the transaction Id and the url of the rpc node which the tx was broadcast to

Example
<pre>
{
  txid: 'ed54fb38dff371be6e3f96e4880405758c07fe6dd1295eb136fe15f311e9ff77',
  nodeUrl: 'http://seed7.ngd.network:10332',
}:
</pre>


====invoke====
Execute a contract invocation.


'''Method Interface'''

<pre>
function invoke({
  scriptHash: string,
  operation: string,
  args: Argument[],
  attachedAssets?: AttachedAssets,
  fee?: string,
  assetIntentOverrides?: AssetIntentOverrides,
  triggerContractVerification?: boolean,
  network?: string,
}): Promise<InvokeOutput>
</pre>


'''Input arguments'''

<pre>
interface InvokeArgs {
  scriptHash: string; // script hash of the smart contract to invoke
  operation: string; // operation on the smart contract to call
  args: Argument[]; // any input arguments for the operation
  fee?: string; // (Optional) The parsed amount of network fee (in GAS) to include with transaction
  network?: string; // Network alias to submit this request to. If omitted, will default to "MainNet".
  attachedAssets?: AttachedAssets;
  
  assetIntentOverrides?: AssetIntentOverrides;
  // A hard override of all transaction utxo inputs and outputs.
  // IMPORTANT: If provided, fee and attachedAssets will be ignored.
  
  triggerContractVerification?: boolean; // Adds the instruction to invoke the contract verification trigger
}

interface Argument {
  type: ArgumentDataType;
  value: any;
}

type ArgumentDataType = 'String'|'Boolean'|'Hash160'|'Integer'|'ByteArray'|'Array'|'Address';

interface AttachedAssets {
  [asset: 'NEO'|'GAS']: string;
}
// KEY: Asset symbol (only NEO or GAS)
// VALUE: Parsed amount to attach

interface AssetIntentOverrides {
  inputs: AssetInput[];
  outputs: AssetOutput[];
}

interface AssetInput {
  txid: string;
  index: number;
}

interface AssetOutput {
  asset: string;
  address: number;
  value: string;
}

</pre>


'''Success return value'''

interface InvokeOutput {
  txid: string; // The transaction ID of the invocation
  nodeUrl: string; // The node which the transaction was broadcast to.
}


'''Error return value'''

string - `NO_PROVIDER`|`CONNECTION_REFUSED`|`SEND_ERROR`|`MALFORMED_ADDRESS`|`CANCELED`


'''Example'''

<pre>
invoke({
  scriptHash: '505663a29d83663a838eee091249abd167e928f5',
  operation: 'storeData',
  arguments: [
    {
      type: 'string',
      value: 'hello'
    }
  ],
  assets: {
    NEO: '100',
    GAS: '0.0001',
  },
  fee: '0.001',
  network: 'TestNet',
})
.then(({txid, nodeUrl}: InvokeOutput) => {
  console.log('Invoke transaction success!');
  console.log('Transaction ID: ' + txid);
  console.log('RPC node URL: ' + nodeUrl);
})
.catch((err: string) => {
  switch(err) {
    case NO_PROVIDER:
      console.log('No provider available.');
      break;
    case CONNECTION_REFUSED:
      console.log('Connection dApp not connected. Please call the "connect" function.');
      break;
    case RPC_ERROR:
      console.log('There was an error when broadcasting this transaction to the network.');
      break;
    case CANCELED:
      console.log('The user has canceled this transaction.');
      break;
  }
});
</pre>


'''Provider Request Handling'''

Upon receiving this request
* Validate and format the inputs
** Script hash is valid
** Format parameters
*** If `byteArray`, convert to appropriate hexstring based on assumed format
* Broadcast the RPC request
* Return the transaction Id and the url of the rpc node which the tx was broadcast to

Example
<pre>
{
  txid: 'ed54fb38dff371be6e3f96e4880405758c07fe6dd1295eb136fe15f311e9ff77',
  nodeUrl: 'http://seed7.ngd.network:10332',
}:
</pre>


===Events===

dApps can listen for events emitted by the wallet provider using the `addEventListener` method.

====addEventListener====

'''Method Interface'''

<pre>
function addEventListener(event: Event, callback: Function): Void
</pre>

'''Input arguments'''

<pre>
enum Event {
  READY = 'READY',
  ACCOUNT_CHANGED = 'ACCOUNT_CHANGED',
}
</pre>

=====READY=====

On a READY event, the callback will fire with a single argument with information about the wallet provider. At any time a READY event listener is added, it will immidiately be called if the provider is already in a ready state. This provides a single flow for dapp developers since this listener should start any and all interactions with the dapi protocol.
<pre>
interface Provider {
  name: string;
  website: string;
  version: string;
  compatibility: string[];
}
</pre>

=====ACCOUNT_CHANGED=====

On a ACCOUNT_CHANGED event, the callback will fire with a single argument of the new account. In the case that the user logs out without providing a new account to connect, this will be null.
<pre>
interface Account {
  address: string; // Address of the connected account
  publicKey: string; // Public key of the connected account
}
</pre>


====removeEventListener====

Removes any callback listeners previously set for a given event.

'''Method Interface'''

<pre>
function removeEventListener(event: Event): Void
</pre>

'''Input arguments'''

<pre>
enum Event {
  READY = 'READY',
  ACCOUNT_CHANGED = 'ACCOUNT_CHANGED',
}
</pre>


==Rational==

This protocol will allow dApp developers to create applications that interact with the NEO blockchain without having to be concerned about managing a full wallet within their application or the details related to handing transaction creation or broadcasting. This will also allow dApps to allow users to transact in a secure fashion that does not require sharing of their private key.

==Implementation==

JS implementation to demonstrate the usage of these methods from a dapp developer.

o3-dapi-neo - [https://github.com/O3Labs/o3-dapi/tree/master/packages/neo Github]
